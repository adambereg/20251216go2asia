# Milestone 3 — Requirements & Boundaries (Points + Referral)

Дата: 2025-12-18  
Статус: **Draft** (артефакт для старта Milestone 3)  
Область: `points-service` + `referral-service` как downstream сервисы, OpenAPI-first.  

## 0) Контекст и обязательные ограничения из ревью Milestone 2

- **Не размывать бизнес-логику в API Gateway**: gateway выполняет роль edge-шлюза (routing, базовые политики, проксирование, observability), но **не владеет** правилами Points/Referral.
- **Vars/Secrets policy должна быть закреплена** (repo/CI vs Cloudflare UI) и отражена в `docs/ops/*source_of_truth*.md`.
- **Source-of-truth документы должны оставаться актуальными** при любых изменениях окружения/контрактов.

## 1) Цели Milestone 3 (Goals)

### 1.1 Points
- Реализовать **учёт** баланса и транзакций Points.
- Реализовать **начисление** Points по внутреннему (service-to-service) контракту с:
  - лимитами (per-action и velocity limit),
  - идемпотентностью,
  - корректностью при ретраях.
- Реализовать пользовательские read-endpoints через gateway: баланс и список транзакций.

### 1.2 Referral
- Реализовать **SSOT** для referral_code и связей referral.
- Реализовать регистрацию/привязку по рефералке и правила выдачи бонусов (в кооперации с Points).
- Реализовать пользовательские endpoints (минимум): получение своего referral_code и базовую статистику.

### 1.3 Интеграции
- Auth → Referral: генерация referral_code на регистрацию.
- Auth → Points: начисление Points за регистрацию/первый вход (как минимум один сценарий в M3).
- Content → Points: начисление Points за регистрацию на событие (если событие уже в M3 scope интеграций; иначе — non-goal).

## 2) Явные границы (Boundaries)

### 2.1 API Gateway (edge)
- **Разрешено**:
  - routing `/v1/points/*`, `/v1/referral/*` на downstream URLs,
  - enforcement user auth (например, проверка JWT через auth-service/политика) и проброс `X-User-ID`,
  - timeouts и отказоустойчивость на уровне прокси,
  - корреляция `X-Request-Id`, базовое логирование.
- **Запрещено**:
  - вычислять/применять доменные правила (лимиты, коэффициенты, eligibility),
  - хранить состояние домена,
  - выполнять “частичное начисление” Points.

### 2.2 Downstream services
- **Points Service**: владелец ledger и правил начисления/лимитов.
- **Referral Service**: владелец referral_code и referral relationships.
- Межсервисные вызовы (auth/content/referral → points) выполняются по внутренним эндпоинтам и аутентифицируются сервисным токеном.

## 3) Выбор механизма идемпотентности (ОБЯЗАТЕЛЬНО)

### 3.1 Нормативное решение
**Для любых начислений Points (internal endpoints) механизм идемпотентности — `external_id` (обязательный) + уникальный индекс на стороне Points Service.**

- `external_id`:
  - генерируется **вызывающим сервисом** (Auth/Content/Referral),
  - должен быть **глобально уникальным** для Points Service,
  - формат: UUIDv4 (рекомендовано) или детерминированная строка вида `<source>:<event>:<sourceEventId>`.
- Points Service гарантирует:
  - повторный вызов с тем же `external_id` **не создаёт** вторую транзакцию,
  - возвращает тот же `transactionId` и консистентный `balance` (в пределах транзакционной семантики).

### 3.2 Почему так (мотивировка)
- Ретраи неизбежны (таймауты 2s, сетевые сбои, 5xx) — нужна идемпотентность “по данным”, а не “по попытке”.
- `external_id` обеспечивает корректность при повторных запросах из разных слоёв (retry в сервисе, retry в gateway, повторная доставка события).

### 3.3 Инварианты идемпотентности
- `external_id` **однозначно** соответствует одному доменному событию начисления.
- Для одного `external_id` payload **не должен** меняться.
  - Если `external_id` уже существует, и новый payload отличается (например, `amount` и/или `action` отличаются) → **409 Conflict**.
  - Событие **логируется как integration error** (ошибка контракта вызывающего сервиса).

### 3.4 Дополнение (необязательное, но допустимое)
Можно поддержать заголовок `Idempotency-Key`, но **SSOT ключом** остаётся `external_id` в теле запроса (для аудитируемости и воспроизводимости).

## 4) Инварианты домена (Domain Invariants)

### 4.1 Points
- Баланс пользователя = сумма применённых транзакций (ledger) с учётом бизнес-правил (например VIP-множитель в ограниченных сценариях).
- Все начисления **append-only**: транзакции не “переписываются”; корректировки делаются отдельными транзакциями.
- Начисление по internal API:
  - либо полностью применено (создана транзакция и обновлён баланс),
  - либо полностью отклонено/пропущено как duplicate (идемпотентность).

### 4.2 Limits
- **Per-action limit**: одно и то же доменное действие не должно бесконечно начисляться одному пользователю (пример: `registration` — 1 раз).
- **Velocity / общий лимит (M3)**: используется **простой per-user cap** на начисления в окне времени (значения **конфигурируемые**, без сложных/композитных правил).
- Лимиты применяются **в Points Service**, а не в gateway.

### 4.3 Referral
- У пользователя может быть **не более одного** “referrer” (L1 связь) — связь создаётся один раз и неизменна.
- `referral_code` уникален и принадлежит одному пользователю.
- Начисление referral бонусов происходит через Points Service и должно быть идемпотентным (через `external_id`).

## 5) Требования к интерфейсам (API-level requirements)

### 5.1 Points (user-facing)
- `GET /v1/points/balance` (через gateway)
- `GET /v1/points/transactions` (через gateway; пагинация)

### 5.2 Points (internal)
- `POST /internal/points/add`
  - auth: service JWT
  - идемпотентность: `external_id` обязателен

### 5.3 Referral (user-facing)
- `GET /v1/referral/code`
- `GET /v1/referral/stats` (минимальная сводка)

### 5.4 Referral (internal)
- `POST /internal/referral/generate-code` (вызывается Auth при регистрации)
- `POST /internal/referral/link` (привязка referee к referrer по коду; вызывается Auth в рамках регистрации)

## 6) Ошибки и деградация (Error & Degradation requirements)

- Межсервисные вызовы должны иметь **таймаут ~2s**.
- При недоступности Points Service:
  - M3: допускается “fail closed” для начислений (возвращаем ошибку вызывающему сервису),
  - read-endpoints пользователя должны возвращать понятную ошибку 5xx и не выдавать некорректные данные.
- Любые отказные сценарии должны логироваться с `requestId`.

## 7) Observability / Audit требования

- Для internal начислений обязательно логировать: `external_id`, `action`, `userId`, результат (`applied/duplicate/rejected`) без утечек секретов.
- Для user endpoints: трассировка по `X-Request-Id`.

## 8) Non-goals (явно не делаем в Milestone 3)

- Списание Points / магазин / redemption / вывод.
- Антифрод/скоринг/ML.
- Многоуровневая реферальная программа (L2+), сложные деревья и награды выше первого уровня.
- Полноценные admin-панели/CRUD доменных сущностей.
- Асинхронные очереди/событийная шина (если появится необходимость — отдельное архитектурное решение).
- Перенос любой доменной логики в `api-gateway`.

## 9) Open questions (для закрытия в архитектуре/OpenAPI)

### 9.1 Решения (зафиксировано для M3)
- **Actions (M3-min)**:
  - `registration`
  - `first_login`
  - `referral_bonus_referee`
  - `referral_bonus_referrer`
  - `event_registration` — **опционально в M3** (только если интеграция Content → Points входит в фактический скоуп Milestone 3; иначе — post-M3).
- **Idempotency conflict policy**: при конфликте payload для существующего `external_id` возвращаем **409 Conflict** (см. §3.3).

### 9.2 Post-M3 (явно не закрываем в M3)
- Публичная детализация “за что начислено” (`metadata` schema/формат) — **post-M3** (если понадобится для UI/аналитики).

