Стратегия PWA-оболочки Go2Asia (App Shell)

# Цели и принципы

•	Единое модульное приложение: архитектура фронтенда построена по принципу “одно приложение – много модулей”. Существует один основной App Shell на домене go2asia.space, который динамически монтирует микрофронтенды модулей (Guru, Atlas, Pulse, Blog, Quest, Russian Friendly, Space, Connect и др.). Пользователь воспринимает это как единое приложение, хотя функционально это набор отдельных модулей.
•	Mobile-first и офлайн-дружелюбность: приложение оптимизировано под мобильные устройства и слабые сети. App Shell загружается быстро, статические ассеты кешируются, значительная часть контента доступна в офлайн-режиме (например, последние просмотренные страницы). Цель – обеспечить работоспособность даже при плохом подключении.
•	Гибкая эволюция модулей: за счёт модульной архитектуры возможны независимые релизы и обновления разных частей без перепубликации всего приложения. Используется федеративная сборка (Module Federation) или альтернативы (Import Maps/ESM) для загрузки модулей, что позволяет развивать каждый раздел автономно.
•	Единая аутентификация: все разделы используют общую систему login/SSO. Реализован единый провайдер аутентификации (Clerk), обеспечивающий один профиль пользователя и сессию на всё приложение. Пользователь авторизуется единожды и его статус распространяется на все модули.
•	CDN и Edge-инфраструктура: развертывание фронтенда происходит на Netlify (статические бандлы), с использованием Cloudflare для глобального кеширования контента, гибких редиректов, добавления security-заголовков и запуска функций на “краю” (Edge Workers) при необходимости. Это обеспечивает быструю доставку и безопасность.

---

# Информационная архитектура и навигация

## Каркас App Shell

Главное приложение (App Shell) задаёт основу UI и навигации, присутствующую во всех разделах:
•	Верхняя панель (Top App Bar): включает бренд/логотип, глобальный поиск по платформе и иконку профиля пользователя (для доступа к настройкам/кабинету).
•	Нижняя навигация (Bottom Nav) на мобильных: отображает основные разделы в виде иконок: «Главная», «Карта» (Guru/Atlas), «Лента» (Pulse), «Квесты» (Quest), «Профиль» (Space). Этот постоянно видимый бар облегчает навигацию по ключевым модулям.
•	Боковое меню (Side Drawer) на планшетах/десктопе: выдвижное меню со ссылками на дополнительные разделы: Blog, Russian Friendly, Connect, Settings и пр. Таким образом, на больших экранах доступны быстрые переходы к всем модулям через меню.
•	Глобальная плавающая кнопка (FAB): контекстно используется для создания нового контента. Например, единая кнопка «+» может открывать меню «создать пост/отзыв/квест/маршрут» в зависимости от контекста экрана.
App Shell отвечает за единообразие навигации и оболочку интерфейса, предоставляя общее окружение для микрофронтендов.

## Маршрутизация и deeplinks

Маршрутизация спроектирована таким образом, чтобы URL-адрес отражал, в каком модуле находится пользователь, и позволял удобно делиться ссылками:
•	Главная страница / лендинг: / – может выступать точкой входа с общим обзором или экраном Guru (гид рядом) по умолчанию.
•	Модули как части пути URL: каждому модулю соответствует свой префикс пути:
•	Guru (гид): URLs вида /guru (главный экран гида), /guru/city/:slug, /guru/route/:id для страниц конкретного города или маршрута.
•	Atlas (карты/локации): /atlas (основной экран карты), /atlas/place/:id для страницы места, /atlas/collection/:slug для подборки мест.
•	Pulse (лента событий): /pulse (список событий), /pulse/post/:id для конкретного события; поддерживаются query-параметры фильтра (например, ?tag=phu-quoc).
•	Blog (статьи): /blog (список статей), /blog/:slug – страница статьи по уникальному slug (читается как SEO-friendly URL).
•	Quest (квесты): /quest – список квестов, /quest/:id – страница квеста, /quest/:id/play – режим прохождения квеста в реальном времени.
•	Russian Friendly (партнеры): /rf – каталог партнёров, /rf/place/:id – профиль партнёрского места, /rf/tag/:slug – подборка/метка партнёров.
•	Space (соцсеть/профиль): /space – профиль/лента пользователя, /space/me – собственный профиль, /space/:username – публичный профиль другого пользователя.
•	Connect (рефералы/партнёры): /connect – главная (статистика), /connect/stats – детальные метрики, /connect/ref/:code – страница регистрации по реф.коду или деталь партнёра.
•	Унифицированные deeplinks: поддерживается схема go2asia://module/path для мобильных приложений, которая соответствует обычным URL. Например, go2asia://guru/city/hanoi ↔︎ https://go2asia.space/guru/city/hanoi. Это облегчает интеграцию с нативными функциями (открытие PWA как native-like).
Такое маршрутизирование позволяет пользователям делиться ссылками на конкретный контент внутри модулей. App Shell обрабатывает навигацию: при переходе на новый маршрут, если соответствующий модуль ещё не загружен, он будет подтянут (см. раздел о микрофронтендах).

---

# Микрофронтенды и сборка

## Подход к модульности

Архитектура фронтенда следует концепции App Shell + Remote Modules:
•	App Shell: основное приложение (React, сборка Vite или Next.js) развёрнутое на go2asia.space – это оболочка, содержащая общий код (навигация, header/footer, сервис-воркер). App Shell умеет загружать другие модули по требованию и выступает контейнером.
•	Модули: каждый функциональный раздел (Atlas, Blog, и т.д.) – это независимый bundle (микрофронтенд). Они публикуются как “remote” модули через механизм Webpack Module Federation либо просто размещаются как ES-модули, управляемые через Import Maps. У каждого модуля свой репозиторий (в монорепо – своя папка в apps/), свой процесс сборки.
•	Lazy Loading модулей: загрузка модулей происходит лениво. Изначально при открытии PWA загружается только App Shell. Когда пользователь переходит в конкретный раздел (например, /blog), App Shell выполняет динамический импорт соответствующего бандла Blog Asia. После загрузки bundle монтируется компонент модуля, и пользователь видит контент. При повторных визитах модуль уже может быть закеширован. Это существенно снижает первоначальный вес загрузки и ускоряет Time-to-Interactive.
•	Изоляция и независимость: микрофронтенды разрабатываются и деплоятся независимо. Общение между ними – через глобальные механизмы (например, Event Bus, см. ниже, или общие состояния). В случае Module Federation, App Shell может предоставлять “host” для remote-Module, или можно использовать Runtime module loading с manifest-JSON (App Shell знает URLы модулей). Важный момент – версионирование: у каждого remote-модуля своя версия, App Shell должен подгружать совместимую версию (CI может обновлять манифест версий после деплоя).

## Общие пакеты и ресурсы

Чтобы не дублировать код и обеспечить консистентность, выделены общие пакеты (shared packages), доступные всем модулям:
•	Дизайн-система и UI-kit: единый набор компонентов интерфейса (кнопки, карточки, навигационные элементы), стили и дизайн-токены (цвета, шрифты, spacing). Эти пакеты лежат в packages/ui и импортируются модулями, чтобы все части приложения выглядели единообразно. Также общий набор иконок, темы для светлой/тёмной схемы.
•	Utility SDKs:
•	Auth SDK: обёртка над Clerk (или иным auth-провайдером) для удобного получения текущего пользователя, JWT токена, проверки ролей и т.п., используемая во всех модулях.
•	Analytics SDK: клиентская библиотека для отправки событий аналитики (единый метод analytics.track(event, payload)), чтобы модули не реализовывали это по-разному. События отправляются на бекенд или внешнюю аналитику (подробно в разделе аналитики).
•	i18n (интернационализация): общий движок локализации (например, i18next), чтобы обеспечивать многоязычность модулей. Общие словари (ру, ви, эн) могут храниться централизованно, а модули подгружают свои namespace по необходимости.
•	API-клиент: библиотека @go2asia/api для обращения к бекенд-сервисам (REST/GraphQL). Включает перехватчики ошибок, автоматическое добавление аутх-заголовков, механизмы ретрая и троттлинга запросов. Это упрощает вызов API для разработчиков модулей и обеспечивает единый подход (например, единое поведение при 401 Unauthorized).
•	Maps SDK: обертка над картографическим API (Leaflet или Mapbox) для единообразного использования карт в Atlas/Guru модулях.
•	Storage SDK: клиент для работы с хранилищем R2 (загрузка/скачивание файлов, получение URL) – чтобы, например, модуль Space мог загрузить фото, а Blog – отобразить изображения из общей CDN.
•	Event Bus (шина событий): реализация простого pub/sub на фронтенде для кросс-модульного общения. Например, событие auth:login публикуется App Shell при логине пользователя – все модули могут подписаться, чтобы обновить свой статус (например, Space покажет новые оповещения). Или событие nav:openPlace – при клике на место в Guru можно пробросить событие, которое перехватит Atlas и откроет страницу места. Такой event bus облегчает интеграцию между микрофронтендами без жёсткой связанности.
Эти общие пакеты хранятся в монорепо (packages/) и версионируются вместе с приложением, что гарантирует совместимость. При сборке они могут быть выносены в отдельный шаренный chunk или pre-loaded в App Shell, чтобы не загружать повторно в каждом модуле.

---

# Аутентификация и сессии

Все разделы приложения разделяют единую систему аутентификации:
•	SSO провайдер: выбран сервис типа Clerk для управления пользователями, OAuth и сессиями. Он обеспечивает единое хранилище пользователей, социальный вход и удобные SDK.
•	Единый домен для Auth: предпочтительно, чтобы все фронтенды работали под общим главным доменом (sub-paths), тогда Clerk SSO автоматически распространяется на все (cookie на .go2asia.space). В случае использования разных поддоменов для модулей – необходимо настроить shared cookies через специальный Proxy или указать Cookie Domain, либо использовать JWT токены в localStorage + передачу между доменами (менее безопасно). Но выбран первый путь: все микрофронтенды размещены под go2asia.space, так что SSO прозрачен.
•	Роли и доступ: вводится единая модель ролей: Spacer (обычный пользователь), VIP, PRO, Partner, Admin и т.д. Эти роли хранятся в профиле пользователя (через кастомные claims в Clerk или отдельный профиль сервис) и доступны всем модулям через JWT или Clerk SDK. Таким образом, любой модуль может проверить: например, является ли пользователь PRO, чтобы показать ему партнерский функционал, или админ ли он для доступа к модерации.
•	Гостевой режим: большая часть контента доступна для неавторизованных пользователей (browse-mode). Например, ленты Blog/Pulse, карты Atlas доступны публично, что важно для вовлечения новой аудитории. Однако действия, влияющие на данные (создать пост, лайкнуть, пройти квест) требуют входа. Гостям UI показывает кнопки “Войти, чтобы продолжить” и т.п. Такой подход (read-open, write-closed) обеспечивает низкий барьер входа.
•	Flow авторизации: при попытке действия требующего логина, происходит вызов Clerk (или провайдера) – либо открывается всплывающее окно OAuth, либо показывается встроенная форма. После успешного входа Clerk выдаёт сессионный токен (httpOnly cookie + JWT). Этот токен автоматически будет отправляться в запросах к API (если cookie, то браузер сам приложит). Для GraphQL/WebSocket может использоваться Bearer из JWT. App Shell через Clerk SDK узнаёт о входе (событие) и обновляет глобальный статус (например, запускает процесс получения профиля). Все микрофронтенды, слушающие события или проверяющие auth.isAuthenticated(), обновят интерфейс (например, скрыв баннер гостя, отобразив аватар).
•	Без швов между модулями: так как SSO единое, переходы между разделами не требуют повторной авторизации. Например, пользователь зашёл в Space (вошёл в систему) – затем переходит в Blog, и уже залогинен (cookie действует). Если некоторые модули развернуты отдельно (на поддоменах), может быть использован подход share JWT via postMessage или shared cookie via wildcard domain.
Аутентификация на уровне API: каждое обращение к приватным endpoint сопровождается проверкой JWT. Возможны два варианта: централизованная проверка (через Auth Service – все запросы проходят через него, проксируются дальше при валидности) или децентрализованная (каждый сервис сам валидирует JWT с помощью публичного ключа Clerk). На старте можно использовать второй вариант для простоты (Clerk предоставляет SDK для Node.js). В дальнейшем, при усложнении auth-логики, Auth Service может взять на себя выдачу своих токенов и централизованный контроль.

---

# PWA-манифест и иконки

Для приложения подготовлен единый Web App Manifest (файл manifest.webmanifest), который описывает установочные параметры PWA:
•	Name и описание: name: "Go2Asia" (отображаемое имя при установке на устройство). Возможно, short_name: "Go2Asia".
•	Start URL: start_url: "/" – приложение всегда запускается с главной страницы (либо Guru как основной модуль). Благодаря этому, при открытии с иконки, пользователь попадает на основной экран.
•	Display mode: display: "standalone" – запускается как самостоятельное приложение без адресной строки браузера.
•	Scope: scope: "/" – PWA имеет доступ ко всему пространству URL под доменом.
•	Иконки: включен набор иконок разных размеров (например, 192x192 и 512x512) и маскируемый значок для адаптации под дизайн устройств. Эти иконки – логотип Go2Asia в требуемых разрешениях. Также генерируются splash-экраны для iOS (разные размеры экранов).
•	Цветовая схема: theme_color и background_color устанавливаются в соответствии с фирменным стилем (значения берутся из дизайн-токенов, напр. основной цвет темы). Это определяет цвет статус-бара и фона при запуске PWA.
•	Prompt установки: PWA будет поддерживать установку на главный экран. Реализуется кастомный prompt: например, после нескольких посещений, приложение само предлагает установить себя (вместо стандартного браузерного диалога). Это улучшает конверсию установки.
Манифест подключён в HTML App Shell. Правильно настроенные иконки и цвета создают нативное ощущение при запуске (например, экран загрузки с фирменным цветом).

---

# Сервис-воркер и офлайн-режим

App Shell регистрирует Service Worker (SW), ответственный за кеширование ресурсов, офлайн-опыт и push-уведомления. Для разработки SW используется библиотека Workbox (Google) либо собственный код, с учётом сложных сценариев.

## Стратегии кеширования

Для разных типов ресурсов применяются оптимальные стратегии кеша (в SW):
•	App Shell и общие бандлы: стратегия Stale-While-Revalidate – при запросе оболочки (HTML, CSS, JS App Shell) сначала берётся кэшированная версия, параллельно SW проверяет обновления на сервере. Бандлы версионированы (например, app~abcd123.js), поэтому при деплое новая версия не конфликтует со старой; SW может агрессивно кешировать надолго. В случае Module Federation remote-модули тоже кешируются как статика.
•	Remote-модули (микрофронтенды): также Stale-While-Revalidate. Фактически, каждый модуль – набор JS/CSS, которые хранятся на CDN с версионированным URL. SW может кешировать их на долгое время, обновляя на фоне при выходе новой версии. Это позволяет, однажды загрузив модуль, открывать его мгновенно офлайн до обновления.
•	API-запросы (динамический JSON контент):
•	Публичные данные (ленты, статьи, места и пр.): стратегия Network-First с fallback в кэш. То есть при запросе, SW сначала пытается получить свежие данные от сервера, если сеть недоступна – возвращает закешированные результаты (которые хранятся ограниченное время). Например, запрос списка статей – если офлайн, SW может отдать последние полученные статьи из IndexedDB.
•	Персональные/чувствительные данные (профиль, приватные сообщения): Network-Only, т.к. их кешировать небезопасно или бесполезно (нужна актуальность). В офлайне просто будет ошибка или сообщение «Вы офлайн». Для таких запросов можно применить стратегию мягкого отказа (graceful degrade).
•	Изображения мест, постов: стратегия Cache-First с ограничением по объёму (LRU-кэш). Т.к. изображения крупные, SW хранит только недавно просмотренные (например, последние ~50 МБ). При переполнении – старые удаляются. Также используются возможности CDN: многие изображения резаются/оптимизируются на лету (см. Cloudflare Image Resizing), что уменьшает их размер и кэш быстрее отдаёт оптимальные версии.
•	Картографические тайлы: также Cache-First с лимитом, например 50–100 МБ, особенно для тайлов вокруг последней известной локации пользователя. Например, если пользователь просмотрел карту конкретного района, тайлы этой области сохранятся, чтобы при офлайне отобразить карту. Возможна гео- предзагрузка: при активном квесте кэшируются тайлы маршрута заранее.
•	Статические ассеты (шрифты, иконки): Cache-First, так как они редко меняются и могут храниться долго.
•	Push payloads: push-уведомления не кешируются – их обрабатывает SW моментально при получении (событие push), показывая пользователю уведомление. Они содержат только короткие данные, и повторное использование не требуется.
Эти стратегии позволяют обеспечить баланс между свежестью и доступностью. Они реализованы через Workbox routing или руками в файле SW. Например, Workbox позволяет декларативно указать: cacheFirst для /images/*, networkFirst с fallback для /api/content/* и т.п.

## Офлайн UX

При отсутствии подключения сервис-воркер обеспечивает пользовательский опыт, информирующий о статусе и предлагающий ранее загруженный контент:
•	Offline Screen: специально разработанная страница, показывающая сообщение наподобие: “Вы офлайн — доступен сохранённый контент”. На ней могут быть ссылки на разделы, которые есть в кеше (например, “Последние статьи”, “Карта последнего города”). Эта страница отображается при запросе любого URL, если ни сеть, ни кэш недоступны – SW выдает редирект на /offline страницу.
•	Atlas/Guru офлайн: приложение сохраняет последние 20–50 объектов (мест, маршрутов), которые пользователь просматривал, а также мини-набор карт тайлов вокруг его последней локации. Таким образом, если пользователь офлайн, открыв Guru или Atlas, он увидит близлежащие места из кэша и карту небольшого радиуса, что может быть полезно без связи.
•	Quest офлайн: если пользователь начал квест, все шаги этого квеста сохраняются локально. Пользователь может продолжать прохождение офлайн; все достижения (чек-поинты) накапливаются в локальном хранилище. При восстановлении связи SW или приложение отправит накопленные результаты на сервер (Background Sync, см. далее).
•	Blog/Pulse офлайн: сохраняются последние N просмотренных постов и статей, чтобы их можно было перечитать без сети. Например, если пользователь открыл несколько статей в онлайне, они остаются в IndexedDB; в офлайне он увидит эти статьи.
Общий подход – кешировать проактивно тот контент, который пользователь скорее всего захочет увидеть снова офлайн. И информировать пользователя, что он находится офлайн, но кое-что доступно.

# Фоновая синхронизация

Service Worker реализует возможности фоновый синхронизации для улучшения UX в офлайне:
•	Background Sync: если пользователь совершил действие без сети (лайк, комментарий, чек-ин в квесте, реферальная регистрация), SW ставит задачу в очередь. При появлении соединения эти задачи автоматически отправляются на сервер. Пользователь при этом либо получает уведомление об успешной отправке, либо ничего не замечает (действие “применится” чуть позже). Это касается небольших операций, которые можно отложить.
•	Periodic Sync: на Android PWA доступен периодический sync. Его можно использовать для периодического авто-обновления некоторых данных в фоне. Например, раз в несколько часов подтягивать обновления активного квеста или проверять новые настройки push-уведомлений. Если это недоступно – аналог можно реализовать при следующем открытии приложения.
Благодаря background sync, пользовательские действия не пропадут при офлайне, а будут гарантированно выполнены позже, улучшая надёжность восприятия (особенно для квестов, рефералок и т.п.).

---

# Уведомления и разрешения

Для вовлечения аудитории реализуется система push-уведомлений и проработан UX запроса разрешений:
•	Push-уведомления: используются внешние push-сервисы как OneSignal или Firebase Cloud Messaging (FCM). Они интегрируются через сервис-воркер App Shell (SW слушает событие push и отображает уведомления). Таким образом, даже если пользователь в данный момент не в приложении, важные сообщения дойдут.
•	Категории уведомлений: предусмотрены различные типы push-сообщений:
•	События квестов (например, новое задание, результат квеста).
•	Ответы на посты или комментарии (социальная активность).
•	Новые места или события рядом (для Guru/Atlas/Pulse, основано на гео).
•	Реферальные события (например, друг зарегистрировался, начислен бонус).
•	Промо от партнёров (Russian Friendly) – новые скидки, предложения.
Пользователь в настройках может управлять, какие категории он хочет получать.
•	Запрос разрешений (Permissions UX): важно правильно запросить у пользователя доступ к пушам и геолокации. Стратегия – контекстный one-time prompt:
•	Геолокация запрашивается когда пользователь действительно нажимает «Определить моё положение» (например, открыв Guru впервые или начиная квест). До этого не тревожим его.
•	Разрешение на уведомления – только после того, как пользователь проявил интерес (например, подписался на какой-то раздел, или завершил квест и может хотеть уведомления о наградах). Не показывать сразу при первом входе, чтобы не отпугнуть.
Следуя этим подходам, мы увеличиваем шанс, что пользователь даст разрешение (понимая зачем), и улучшаем его опыт.

---

# Данные и API-слой

Между фронтендом и множеством бэкенд-сервисов нужен удобный слой интеграции:
•	API-шлюз на Edge: реализуется единая точка входа для API-запросов – например, Cloudflare Worker (на Workers или сервис Hono) на адресе /api/*, который маршрутизирует запросы к нужному микросервису. Это выполняет роль API Gateway: можно централизованно обрабатывать аутентификацию, CORS, rate-limit, а затем прокидывать на нужный сервис (Auth, Content, и т.д.).
•	Клиентский SDK (@go2asia/api): на фронте все запросы к API делают через общую библиотеку. Она берёт на себя:
o	Добавление токена авторизации к каждому запросу (например, цепляет Clerk JWT или другую авторизацию).
o	Глобальный обработчик ошибок (например, если получен 401, можно инициировать логаут/обновление токена; если 500 – показать user-friendly сообщение).
o	Механизмы retry для нестабильных соединений: автоматический повтор запросов при временных ошибках или таймаутах.
o	Троттлинг: предотвращение спама запросами, если пользователь слишком часто дергает (встроенный debounce).
o	Использование заголовков ETag/If-None-Match для поддержки кеширования ответов API на клиенте (HTTP caching для API).
•	Локальный кэш данных: кроме SW-кеша, фронтенд может использовать IndexedDB (например, через библиотеку Dexie) для хранения сложных структур данных. Например, списки объектов, на которые были запросы, сохраняются в IndexedDB, чтобы быть доступны без интернета. SW может загружать туда данные при sync, а фронт – читать оттуда при офлайне.
•	Форматы данных: все сервисы используют унифицированные DTO (Data Transfer Object) – определённые схемы (версионируемые). Например, объект PostDTO имеет поля (id, title, content, tags, etc.) и при развитии API изменения происходят по правилам семантической версии, чтобы фронты могли адаптироваться. Это документируется в контрактном пакете.
Такой слой упрощает для фронтенд-разработчиков работу с множеством сервисов: для них все API выглядят как один (единый URL, один SDK). А на бэкенде даёт гибкость менять маршрутизацию (например, перенаправить некоторые вызовы на новый сервис, не трогая фронт).

---

# Карты и гео-функции

Картографические возможности – важная часть экосистемы (Atlas, Guru, RF):
•	Выбор SDK: используется либо Leaflet (опенсорс JS-библиотека для карт) с тайлами OpenStreetMap, либо Mapbox GL JS (более богатый, с собственными тайлами). Выбор зависит от бюджета (Mapbox платный) и требуемых функций (3D, стильные карты). В любом случае, интерфейс абстрагирован (через Maps SDK), так что сменить провайдер можно.
•	Доступ к геолокации: используется стандартный Browser Geolocation API. При первом запросе позиции пользователя – выводится разрешение (как описано выше). Если пользователь отказал, контент Guru/Atlas ограничивается (например, показать дефолтный регион). Важно graceful degrade: если гео недоступна, можно позволить ввод своего местоположения вручную или просто не показывать “рядом со мной”.
•	Кластеризация объектов: для отображения множества точек (например, сотни мест в Atlas, пользователей в Space на карте) используется кластеризация на фронте или бэкенде. Leaflet и Mapbox поддерживают clustering (либо через плагин). Таким образом, на зуме карты пользователь видит скопления (“+10”) вместо сотни маркеров.
•	Маршрутизация к внешним картам: если нужно проложить маршрут или открыть адрес в навигаторе, предоставляется возможность открытия внешних приложений (Google Maps, Apple Maps) через deeplink. Например, кнопка “Открыть в Google Maps” рядом с адресом места – вызывает geo: или прямой URL Google Maps.
•	Офлайн-карты: для офлайн-режима кешируется небольшой регион тайлов (как упоминалось). Плюс, можно использовать функцию Mapbox GL для сохранения стилей и данных offline (если премиум). В базовом решении – ограничимся кешем последних просмотренных областей.
Эти меры обеспечивают функциональность карт даже при плохом интернете, а интеграция с внешними сервисами делает опыт пользователя бесшовным, если нужно полноценную навигацию.

---

# Безопасность и защита

Безопасность PWA-приложения достигается сочетанием правильной конфигурации фронтенда и возможностями Cloudflare/браузеров:
•	Content Security Policy (CSP): App Shell задаёт строгую CSP, разрешая контент только с доверенных доменов: собственного (go2asia.space), CDN Netlify/Cloudflare, доменов карт (например, api.mapbox.com), аналитики (Sentry, etc.), шрифтов (Google Fonts или локальные). Все скрипты и стили либо inline с hash, либо с указанием allowed sources. Это предотвращает загрузку несанкционированного кода.
•	Subresource Integrity (SRI): для критичных внешних скриптов (если используются CDN, например, Mapbox JS/CSS) подключаются хэши SRI. Хотя предпочтительнее вообще захостить все библиотечные скрипты локально (в бандле), на случай CDN это даст уверенность, что скрипт не подменён.
•	Протокол и заголовки: весь трафик – по HTTPS (HTTP/2 или HTTP/3). Включён HSTS (Strict-Transport-Security) заголовок, чтобы браузеры всегда принудительно использовали HTTPS. Также включены заголовки для защиты контекста: COOP/COEP для изоляции Execution Context (защита от Spectre и пр., если уместно), X-Frame-Options: DENY (приложение не должно инлайниться в чужие iframe).
•	Хранение токенов: предпочтительно использовать httpOnly cookies для сессий Clerk – они недоступны JS и защищены от XSS. Если JWT нужно читать на фронте, то срок жизни делается коротким и есть механизм ротации (refresh token). В целом, сократить поверхность: не хранить ничего чувствительного в localStorage.
•	Ограничение запросов и ботов: как описано для фазы 4, Cloudflare позволяет на уровне сети ставить rate limit и капчи. Это в основном backend-задача, но фронт тоже может кое-что: например, добавить небольшие задержки перед отправкой форм, использовать CSRF-токены для POST-запросов к API, чтобы затруднить автоматизированные атаки.
Суммарно, PWA-приложение выстроено безопасно: код подписан (integrity), данные передаются только шифрованно, сессии защищены, а дополнительные проверки на Edge отфильтровывают нежелательный трафик.

---

# Производительность и качество

Высокая производительность критична для мобильного UX. Задаются конкретные метрики и применяются оптимизации:
•	Performance-бюджеты: устанавливаются цели Core Web Vitals: Time to Interactive < ~3с на связи 4G, Largest Contentful Paint < 2.5с, input latency < 100-200мс. Эти показатели регулярно измеряются (через Lighthouse, Web Vitals) и регрессии не допускаются.
•	Критический рендеринг: минимизируется количество критических ресурсов:
•	Разделение кода (code-splitting) по роутам – пользователю грузится только то, что нужно для текущего экрана.
•	Выделяется критический CSS (например, стиль шапки и основных layout) – либо инлайнится в <head> для мгновенного отображения, остальной CSS грузится async.
•	Используется prefetch/prerender: App Shell может предзагружать куски кода следующего экрана, если высокая вероятность навигации (например, пользователь часто открывает карту – подгрузить Atlas заранее).
•	Оптимизация изображений: все изображения используются в современных форматах (WebP, AVIF) с fallback для несовместимых браузеров. Реализована lazy-loading изображений вне экрана (через loading="lazy" или IntersectionObserver). Миниатюры (placeholder) отображаются до загрузки полных изображений, чтобы пользователь видел заполнение контента.
•	Мониторинг производительности: подключены сервисы как Sentry (для отслеживания runtime ошибок на фронте) и, например, LogRocket или собственный трекер, чтобы видеть реальные показатели пользователей. В частности, собираются Web Vitals метрики (LCP, FID, CLS) для реальных пользователей – это помогает находить перфоманс-проблемы на различных устройствах и сетях.
•	Quality Assurance: автоматизировано тестирование ключевых сценариев. Юнит-тесты для утилит, интеграционные тесты для критичных компонентов, возможно, визуальные regression тесты для UI. Перед релизом проходит audit Lighthouse на performance, accessibility, SEO.
Таким образом, поддерживается баланс – богатый функционал, но при этом быстрая загрузка и плавная работа, что особенно важно для аудитории путешественников с разными устройствами.

---

# Аналитика и эксперименты

Для развития продукта важно отслеживать поведение пользователей и проводить эксперименты:
•	Единый слой событий: как упоминалось, реализован единый метод analytics.track(event, payload). Разные модули вызывают его для различных событий (просмотр места, старт квеста, приглашение друга, и т.п.). Внутри SDK каждое событие получает унифицированный формат (например, {event: "view_place", module: "Atlas", userId: ..., details: {...}}) и отправляется на бэкенд (в аналитическую систему или просто логируется). Единая схема событий позволяет легко агрегировать данные.
•	A/B тестирование и feature flags: App Shell включает механизм фича-флагов (например, на базе ConfigCat, LaunchDarkly или open-source Unleash). При старте приложения App Shell может запросить конфигурацию флагов (или взять из embed-конфига) – какие эксперименты включены и кому (на основе % пользователей, регионов и пр.). На основе этого:
o	Можно включать/выключать экспериментальные UI-элементы в модулях (Bolt-модули могут получать через контекст: флаг X=true => показывать новую кнопку).
o	Делать AB-тесты: часть пользователей видит одну версию функционала, часть другую, а события аналитики помечаются вариантами, что позволяет сравнить метрики (конверсия, вовлечённость и т.д.).
o	Примеры: экспериментальный дизайн профиля, альтернативный алгоритм сортировки ленты, новый виджет рекомендаций – включается через флаг для 10% аудитории и измеряется эффект.
•	Атрибуция и реферальная аналитика: фронтенд обрабатывает deeplink-параметры (UTM-метки, реферальные коды) при заходе пользователя. Например, если новый пользователь пришёл по ссылке go2asia.space?ref=ABCD123&utm_campaign=invite, App Shell сохранит эти параметры (в cookie или localStorage), а при регистрации передаст их в Referral Service – тем самым обеспечивая связь “кто пригласил” и эффективность кампаний.
Всё это дает команде продуктовую информацию: как используются функции, какой вариант дизайна лучше конвертит, откуда приходят пользователи и т.д. Главное – встроить сбор данных изначально, чтобы затем не гадать, а опираться на факты.

---

# CI/CD и релизы

Процесс разработки фронтенда организован в рамках монорепозитория:
•	Структура репо (монорепо): исходный код организован по папкам apps/ и packages/. Например:
o	apps/app-shell – код App Shell,
o	apps/atlas, apps/guru, ... – микрофронтенды,
o	packages/ui, packages/api, packages/auth – общие пакеты (дизайн-система, SDK и др.).
•	Автоматический деплой: настроена интеграция с GitHub. На каждый PR происходит сборка и деплой превью на Netlify (отдельный URL). При мерже в main – деплой в продакшн:
o	App Shell – деплоится в основное приложение (например, Netlify site для go2asia.space).
o	Каждый модуль – может деплоиться независимо, как отдельный сайт (например, remote bundles хранятся по URL типа https://cdn.go2asia.space/atlas/v1/...). Используется стратегия independent deployments: модули версиируются и разворачиваются отдельно.
•	Возможны канареечные релизы модулей: напр., Atlas v1.1 выкатывается для 10% пользователей (через feature flag, либо через CDN url override) перед полной заменой.
•	Версионирование: принимается semver-подход для модулей и App Shell. В CHANGELOG фиксируются изменения. Выпуск новых версий сопровождается обновлением manifest или модульных версий. Feature-флаги позволяют плавно включать фичи даже после деплоя (dark launches).
Такая CI/CD схема гарантирует быстрое и безопасное выкатка обновлений. Если баг – можно мгновенно откатить модуль до предыдущей версии. Новые модули подключаются, просто добавив их в список в App Shell (и настроив автодеплой). В сумме, это поддерживает идею “ship fast, iterate fast” для PWA.

---

# Доступность и локализация

Эти аспекты часто упускают, но для глобальной аудитории и разнообразных пользователей они важны:
•	A11y (Accessibility): соблюдаются принципы доступности WCAG. Дизайн-токены обеспечивают достаточный контраст цветов текста и фона. Все интерактивные элементы имеют чёткие фокус-стили (для навигации с клавиатуры), используются ARIA-атрибуты для скринридеров (например, описания кнопок, роли заголовков). Проходят тестирование через доступность-линтеры и вручную, чтобы PWA была удобна для максимум людей.
•	Интернационализация (i18n): платформа изначально многоязычна. Основные целевые языки: русский, английский, вьетнамский (в перспективе добавятся тайский и др.). Реализовано через серверные словари (загрузка JSON с переводами) с возможностью ленивой подгрузки необходимых namespaces. Пользователь может переключать язык, либо язык выбирается по предпочтениям браузера. Все тексты в интерфейсе – через ключи локализации.
•	RTL-готовность: заложена поддержка языков с письмом справа-налево (например, арабский) – пока таких пользователей нет, но стили пишутся с учётом потенциальной смены направления (flex/grid layouts могут автоматически переворачиваться). Это на перспективу, чтобы не переделывать потом.
За счёт соблюдения этих принципов PWA Go2Asia сможет обслуживать разноплановую аудиторию: как по языкам, так и по ограниченным возможностям. Уделение внимания a11y и локализации с самого начала экономит ресурсы в будущем и расширяет охват приложения.

---

# Этапы внедрения: MVP и V2

Постепенное создание PWA-оболочки разбивается на две основные итерации:
MVP (первые 4–6 недель): минимально жизнеспособный продукт, включающий: 
- App Shell с базовым каркасом, PWA-манифестом и работающим сервис-воркером (кеширует оболочку и базовые данные). 
- Модули-вкладки: реализованы основные контентные разделы в упрощённом виде: Guru, Atlas, Pulse, Blog – доступны только для чтения контента (просмотр мест, статей, ленты без создания). 
- Единый логин (SSO): подключён Clerk, обеспечен единый вход и простой профиль пользователя (возможно, только имя/аватар). 
- Базовый офлайн: кешируется App Shell и последние списки контента (чтобы главные экраны работали офлайн). 
- Глобальная навигация: реализованы основные элементы UI – нижняя навигация, верхний бар, маршрутизация по URL, deeplinks (в том числе поддержка go2asia://). 
- Аналитика (минимум): настроен сбор базовых событий (например, открытие раздела) и интегрирован Sentry для ошибок.
Этот MVP даёт ощущение цельного приложения и уже полезен пользователям: можно читать контент, видеть карту, зарегистрироваться.

V2 (следующие 8–12 недель): расширение функциональности после MVP: 
- Quest: добавлен полноценный модуль Quest с офлайн-сценарием прохождения и background sync для чекпоинтов. 
- Russian Friendly: реализован каталог партнёров с отзывами и отметками на карте (возможно, упрощённая версия кабинета партнёра). 
- Space: социальный модуль – возможность публиковать посты, комментировать, лайкать; плюс подключение push-уведомлений для социального взаимодействия. 
- Connect: реферальный кабинет – отображение рефералов, статусов, возможно активация реферальных кодов. 
- Улучшенный офлайн для медиа: кэширование больших данных – тайлов карт, изображений постов – с управлением (например, настройки объёма). 
- A/B эксперименты и персонализация: начало использования фича-флагов для выборочного включения новых функций и персонализированного контента (например, разные рекомендации для разных групп).
После реализации V2, PWA-оболочка будет включать практически все запланированные разделы и основные фичи, предоставляя пользователям ощущение единого приложения с богатыми возможностями.

---

# Ограничения PWA и обходные пути

Хотя PWA-подход дает много преимуществ, есть известные ограничения, которые учитываются:
•	Push на iOS: поддержка push-уведомлений в iOS PWA появилась, но с некоторыми ограничениями (например, разрешение истекает через 8 недель, нет background updates). Решение: использовать проверенные сервисы (Pushwoosh, Firebase APNs) и запрашивать разрешение just-in-time (в контексте действия). Также, важно информировать пользователя на iOS о необходимости периодически открывать приложение для обновления токена.
•	Фоновые задачи: мобильные браузеры ограничивают фоновые процессы. Тяжёлые задачи (генерация отчётов, длительные вычисления) лучше выполнять на сервере или Edge. На клиенте ограничиться Background Sync и Periodic Sync для коротких отложенных операций. Например, не пытаться реализовать сложный видео-рендеринг в SW.
•	Офлайн карты и данные: хранение большого объёма офлайн-данных ограничено. Нельзя кэшировать целые страны карт – только ограниченный регион. Обходной путь: сделать явную предзагрузку – позволить пользователю скачать офлайн-пакет для выбранного города/региона, чтобы он сам контролировал объём. Также, крупные данные (видео, большое кол-во изображений) PWA хранить неэффективно – их всегда требовать онлайн или стримить.
В целом, платформа придерживается принципа PWA-first: максимальные возможности через веб-оболочку на go2asia.space, ленивое монтирование модулей, мобильная оптимизация и офлайн-дружелюбность. Интерактивные пользовательские разделы (карты, ленты, квесты) делают упор на мобильность и офлайн, а более “кабинетные” разделы (партнёрские, аналитика) – просто адаптированы под мобильные устройства без чрезмерных офлайн-функций. Такой подход обеспечивает ощущение “одного приложения” для пользователя, быстрый выпуск новых модулей и комфортный опыт для путешественников, даже когда интернет подводит.

