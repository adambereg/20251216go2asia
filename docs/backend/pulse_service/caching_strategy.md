# Pulse Service — Стратегия кеширования

## Цели кеширования

- Ускорить выдачу массовых запросов:
  - афиша по городу на ближайшие дни;
  - события на выходные;
  - блоки “топ событий” на главной.
- Снизить нагрузку на БД и интеграции при росте трафика.

## Уровни кеширования

### 1. Кеш ответов API (Response Cache)

- `GET /events`:
  - популярные запросы:
    - `city_id`, `mode=today`, `mode=weekend`, `mode=upcoming`.
  - TTL: 60–120 секунд (достаточно для афиши, где обновления не каждую секунду).
- `GET /events/{id}`:
  - короткий TTL (например, 30–60 секунд) — стабилизирует нагрузку при пиках.

### 2. Гео-кеш для nearby (Фаза 2)

Для `GET /events/nearby`:

- Кеш по гео-тайлам (например, по сетке 0.01° x 0.01°).
- TTL: 60 секунд.
- Ключ: `nearby_events:{tile}:{time_window}`.

### 3. Кеш справочников

- `categories`, `tags`:
  - загружаются редко;
  - TTL: 5–15 минут (или in-memory на инстансе).

## Инвалидирование кеша

- При изменении событий (create/update/publish/cancel):
  - целенаправленное сброс кешей:
    - по `city_id`;
    - по `place_id`;
    - для `nearby` — на уровне тайла.
- Возможна грубая стратегия:
  - просто истечение TTL + фоновое обновление для популярных ключей.

## Отношение к кэшу в других сервисах

- **Guru** может иметь свой кеш поверх Pulse (чтобы не обращаться к Pulse на каждый сдвиг карты).
- Pulse должен быть tolerant:
  - кеш всегда может быть немного “старым” (новые события не появятся мгновенно);
  - при критических изменениях (например, отмена событие) — стоит инвалидировать соответствующие ключи оперативно (Фаза 2).

## Технологии

- Redis:
  - основной стор для кеша.
- Возможен in-memory кеш на уровне приложения для очень частых запросов (категории, константы).
