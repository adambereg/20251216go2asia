# Guru Service — Архитектура

## Общая роль

Guru Service — не хранит основной контент, а:

- оркестрирует запросы к другим микросервисам,
- нормализует данные,
- добавляет гео-логику и немного персонализации.

Это **тонкий, но центральный слой** “Near Me”.

## Слои

1. **API Layer**
   - REST-эндпоинты `/api/guru/v1/...`;
   - валидация query-параметров;
   - аутентификация (для preferences);
   - обработка ошибок (таймауты интеграций, падения).

2. **Application Layer**
   - Use-cases:
     - `GetNearby`,
     - `GetNearbyPlaces`,
     - `GetNearbyEvents`,
     - `GetWhatToDoPreset`,
     - `GetUserPreferences`,
     - `UpdateUserPreferences`,
     - (Ф2) `GetHistory`, `SaveHistory`, `GetSaved`, `SaveEntity`.
   - Координация параллельных запросов к другим сервисам и мердж результатов.

3. **Integration Layer**
   - HTTP-клиенты или gRPC (в зависимости от общей архитектуры):
     - Atlas Service — `/places/nearby`,
     - Pulse Service — `/events/nearby`,
     - Rielt Service — `/offers/nearby` (Ф2),
     - RF Service — `/venues/nearby` (Ф2),
     - Quest Service — `/quests/nearby` (Ф3).
   - Настройки таймаутов, ретраев, fallbacks.
   - интеграцию с User/Space/Connect Service для получения списка PRO-пользователей с флагом visible_in_guru, их базовых локаций и специализаций.

4. **Domain Layer**
   - Модель `GuruEntity` и логика нормализации:
     - маппинг разных источников в общий формат;
     - единые правила сортировки, весов, фильтров.
   - Логика пресетов “what-to-do”.
   - entity_type = guru
   - source = guru_pro

5. **Persistence Layer**
   - Небольшие таблицы:
     - `guru_user_preferences`,
     - (Ф2) `guru_search_history`,
     - (Ф2–3) `guru_saved_entities`.
   - Всё “тяжёлое” (контент) хранится в профильных сервисах.

6. **Caching Layer**
   - Redis:
     - кеш результатов `/nearby` по гео-тайлам и наборам фильтров,
     - кеш пресетов “what-to-do” по городу/таймслоту.
   - in-memory:
     - базовые конфиги, список пресетов и их настройки.

## Потоки данных

### Запрос `/nearby`

1. API → Application → Integration:
   - параллельные запросы в Atlas, Pulse, и др. сервисы.
2. Получение результатов:
   - нормализация → массив `GuruEntity`.
3. Сортировка:
   - по расстоянию,
   - с дополнительными весами (рейтинги, наличие RF, наличие событий в ближайшее время и т.п.).
4. Ответ клиенту.

### Стратегия отказоустойчивости

- Если один из сервисов (например, Pulse) недоступен:
  - Guru всё равно отдаёт частичный список (места из Atlas, жильё из Rielt и т.п.),
  - эффект деградации контролируемый (в логах отмечаем падение интеграции).
- Важно: не блокировать весь `/nearby` из-за падения одного источника.

## Масштабирование

- Guru — CPU/IO-bound (много сетевых запросов).
- Горизонтальное масштабирование:
  - несколько инстансов за API Gateway.
- Оптимизации:
  - агрессивное кеширование,
  - аккуратный выбор таймаутов и лимитов (например, не запрашивать более 50–100 объектов от каждого сервиса за раз).
