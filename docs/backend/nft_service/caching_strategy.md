# NFT Service — Caching Strategy

Цель кеширования — ускорить:

- отображение профиля пользователя и витрины достижений,
- частые запросы типов и уровней NFT.

---

## 1. Кеш NFTType и NFTLevelRule

Эти данные меняются редко:

- можно держать их в памяти сервиса (in-memory cache),
- либо в Redis с TTL (например, 5–30 минут),
- кеш инвалидируется при изменении типов/уровней через админ-интерфейс.

Ключи:

- `nft:type:code:{code}`
- `nft:type:levels:{type_id}`

---

## 2. Кеш списка NFT пользователя

Для профиля пользователя:

- ключ: `nft:user:{user_id}:summary`
- содержимое:
  - список активных NFTInstance (без глубоких деталей аудита),
  - возможно, сгруппировано по категориям.

Обновление:

- после каждой успешной операции, влияющей на NFTInstance пользователя:
  - создание / level_up / change_status / mint_status_update,
  - кеш перезаписывается свежими данными или помечается как инвалидный.

TTL:

- можно выставить TTL 1–5 минут как дополнительную защиту.

---

## 3. Что НЕ кешируем

- `NFTMintQueue` — должна быть максимально консистентной;
- `NFTAuditLog` — как журнал истории;
- тяжёлые выборки для аналитики:
  - лучше выполнять напрямую по БД или через отдельный аналитический контур.

---

## 4. Связь с внешними кешами (API Gateway / BFF)

Часть кеширования (особенно для публичных профилей PRO) можно перенести:

- на уровень BFF,
- на уровень edge-кеша (CDN, API Gateway),
- при этом NFT Service остаётся источником истины.
